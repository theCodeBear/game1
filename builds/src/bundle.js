/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided:  */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__gameLib__ = __webpack_require__(/*! ../../gameLib */ 1);\n\n\n__WEBPACK_IMPORTED_MODULE_0__gameLib__[\"a\" /* default */].init();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz85NTUyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnYW1lIGZyb20gJy4uLy4uL2dhbWVMaWInO1xuXG5nYW1lLmluaXQoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2luZGV4LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n");

/***/ }),
/* 1 */
/*!***************************!*\
  !*** ../gameLib/index.js ***!
  \***************************/
/*! exports provided: default */
/*! exports used: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("/*\n * library needs to expose public methods init, update (more to come) methods\n * library needs to expose public setters loadMap, setTileSize, createPlayer\n * library needs to expose public getters getMap, getPlayer, getCanvas??, getContext??\n * keys pressed, drawMap, updatePlayerToMap should be run on update\n*/\n\nlet game = {\n  // DATA\n  tileSize: null,\n  map: null,\n  player: null,\n  canvas: null,\n  ctx: null,\n  // FUNCTIONS\n  init: null,\n//  verifyMapDimension: null,\n//  customError: null,\n//  updatePlayerToMap: null,\n//  update: null,\n  setTileSize: null,\n  createPlayer: null,\n  setMap: null,\n//  keydown: null,\n//  drawMap: null\n};\n\ngame.createPlayer = (avatar, color, x, y) => {\n  game.player = {\n    x,\n    y,\n    avatar,\n    color,\n    lastMove: [],\n    move: (x,y) => {\n      // if (map[this.x+x][this.y+y] != \"#\") {\n      game.player.x += x;\n      game.player.y += y;\n      update();\n      // }\n      game.player.lastMove = [x,y];\n    }\n  };\n};\n\ngame.setMap = (mapArray) => {\n  if (game.map) return;\n  game.map = mapArray;\n};\n\ngame.setTileSize = (tileSize) => {\n  if (game.tileSize) return;\n  game.tileSize = tileSize;\n};\n\n        let tileSize = 20;\n\n        let map = [\n                \"...............\",\n                \"...............\",\n                \"...............\",\n                \"...............\",\n                \"...............\",\n                \"...............\",\n                \"...............\",\n                \"#..............\",\n                \"#...MZW........\",\n                \"#..............\",\n                \"#..............\",\n                \"#..............\"\n                ];\n\n\n    // Use this method of creating player objects because there will only be a single player\n        /*var player = {\n            x : 8,\n            y : 8,\n            avatar : \"@\",\n            color : \"orange\",\n            lastMove : [],\n            move : function(x,y) {\n                // if (map[this.x+x][this.y+y] != \"#\") {\n                    this.x += x;\n                    this.y += y;\n                    update();\n                // }\n                this.lastMove = [x,y];\n            }\n        };*/\n\n\n        window.addEventListener(\"keydown\", (event) => {\n            switch(event.keyCode) {\n                case 37:\n                    game.player.move(-1,0);\n                    update();\n                    break;\n                case 38:\n                    game.player.move(0,-1);\n                    update();\n                    break;\n                case 39:\n                    game.player.move(1,0);\n                    update();\n                    break;\n                case 40:\n                    game.player.move(0,1);\n                    update();\n                    break;\n            }\n        });\n\n        game.init = () => {\n            game.canvas = document.getElementById(\"myCanvas\");\n            game.canvas.width = window.innerWidth;\n            game.canvas.height = window.innerHeight;\n            game.ctx = game.canvas.getContext(\"2d\");\n\n            game.ctx.font=\"17px Andale Mono\";\n            game.ctx.textAlign = \"center\";\n            game.ctx.textBaseline = \"top\";       // top means that the top of the character space\n                                            // draws at the y-coordinate you give it.\n            game.createPlayer('@', 'orange', 8, 8);\n            game.setTileSize(tileSize);\n            game.setMap(map);\n            update();\n\n        };\n\n    // This defines a new method for array objects called drawMap. So this is the draw method\n    // for whatever map is active. I could make a roguelike game dev library and include this.\n    // Can optinonally include a two element color array representing the color of the map and\n    // color of the grid. If I were to put this in a game library I would always need to supply\n    // as a parameter the height and width of each block in the grid/map. Maybe would also need\n    // optionally parameters for the x,y coords to begin drawing the map at and the height and\n    // width of the map in blocks. And borderColor, if given, will give the whole map a border\n    // of that color, if it is not given then there will be no border. Also need to make it so\n    // it is only going through the logic of drawing what will be on screen, and not just the\n    // whole map.\n    // Also right now it always starts drawing at grid block (0,0), need to add two parameters\n    // to represent drawing starting at a different block in the map. Could be just two params\n    // at the end of the param list, but have to figure out how I keep track of it outside the\n    // function.\n    // The function expects a square map (or at least the first row must be as long as the\n    // others).\n        Array.prototype.drawMap = function(grid, colors, mapWidth, mapHeight, mapX, mapY, borderColor) {\n\n        // Clear the screen for the next frame\n            game.ctx.clearRect(mapX,mapY,mapWidth*tileSize,mapHeight*tileSize);\n\n        // Set default values of zero for mapX and mapY if those arguments aren't given.\n            if (typeof(mapX) === 'undefined') mapX = 0;\n            if (typeof(mapY) === 'undefined') mapY = 0;\n\n        // Handle mapHeight parameter if larger than entire map or <= 0\n            mapHeight = verifyMapDimension(mapHeight, this.length);\n\n        // Handle mapWidth parameter if larger than entire map of <= 0\n            mapWidth = verifyMapDimension(mapWidth, this[0].length);\n\n        // Draw map to canvas\n            for (let row=0; row < (mapHeight = mapHeight || this.length); row++) {\n                for (let col=0; col < (mapWidth = mapWidth || this[row].length); col++) {\n                // output ASCII map characters\n                    if (colors)\n                        colors[0] ? game.ctx.fillStyle = colors[0] : game.ctx.fillStyle = \"white\";\n                    else\n                        game.ctx.fillStyle = \"white\";\n                    // if (this[row][col].color)    // will this work?? map objects having unique colors.\n                    //     game.ctx.fillStyle = this[row][col].color;\n                    game.ctx.fillText(this[row][col], col*tileSize+(tileSize/2)+mapX, row*tileSize+mapY);\n                // output grid:\n                    if (grid==true) {\n                        if (colors)\n                            colors[1] ? game.ctx.strokeStyle = colors[1] : game.ctx.strokeStyle = \"white\";\n                        else\n                            game.ctx.strokeStyle = \"white\";\n                        game.ctx.strokeRect(col*tileSize+mapX,row*tileSize+mapY,tileSize,tileSize);\n                    }\n                // Handle drawing (or not drawing) of map border.\n                    if (borderColor) {\n                        game.ctx.strokeStyle = borderColor;\n                        game.ctx.strokeRect(mapX, mapY, mapWidth*tileSize, mapHeight*tileSize);\n                    }\n                }\n            }\n            updatePlayerToMap(mapX, mapY);\n        }\n\n\n    // Will also be in my roguelike JS game library for moving the map on screen.\n        Array.prototype.moveMap = function() {\n            ;\n        }\n\n\n\n    // Handles map width and map height display dimensions if they are bad inputs - either too\n    // large (larger than map) or too small (<= 0). Fixes the dimensions or throws an error.\n    // First parameter is the dimension of the map being displayed, second parameter is the map's\n    // total size in that dimension.\n        function verifyMapDimension(displayDimen, totalDimen) {\n            try {\n                // if mapHeight or mapWidth is given as 0 or negative, throw an error.\n                if (displayDimen <= 0)\n                    throw new customError(\"Zero or negative number sent to drawMap() for viewable map dimension parameter\");\n                // if display dimension is larger than map set it equal to that of entire map\n                else if (displayDimen > totalDimen)\n                    displayDimen = totalDimen;\n            } catch(err) { console.log(err); }          // print possible error to console\n            finally { return displayDimen; }\n        }\n\n\n\n\n    // Creating a function to call to display custom errors. Just do: throw new customError()\n    // with the error message as the argument. Then send the error to the console.log() in the\n    // catch block. This can also be part of my roguelike game dev library since I give the\n    // errors a name appropriate to the library.\n        function customError(message) {\n            this.stack = new Error().stack;\n            this.name = \"Todd Roguelike Library Error\";\n            this.message = (message || \"\");\n        }\n        customError.prototype = new Error();//Error.prototype;\n\n    // Another way of doing a custom error:\n        // function customError() {\n        //     let err = Error.apply(this,arguments);\n        //     err.name = this.name = \"Todd Library Error\";\n        //     this.stack = err.stack;\n        //     // this.message = err.message;\n        //     return this;\n        // }\n\n        // function updatePlayerToMap() {\n\n        // }\n\n    // Once the player has moved this function clears from the display what is normally\n    // occupying that space on the map, and outputs the player's character instead.\n        function updatePlayerToMap(mapX, mapY) {//, mapWidth, mapHeight) {\n            console.log(game.player.x);\n            if (game.map[game.player.x][game.player.y] != \"#\") {\n                // clear display space where player is moving to.\n                game.ctx.clearRect(game.player.x*tileSize+mapX, game.player.y*tileSize+mapY, tileSize, tileSize);\n                // output the player to the screen in the correct spot\n                game.ctx.fillStyle = game.player.color;\n                game.ctx.fillText(game.player.avatar, game.player.x*tileSize+(tileSize/2)+mapX, game.player.y*tileSize+mapY);\n            } else {\n                game.player.x += -game.player.lastMove[0];\n                game.player.y += -game.player.lastMove[1];\n            }\n        }\n\n    // Game update function (the game loop)\n        function update() {\n\n            game.map.drawMap(false, [\"green\",\"blue\"], 10, 33, 100, 50);//, \"rgb(0,200,0)\");\n        }\n\n\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (game);\n\n\n\n\n\n\n/*\nvar game = {\n  // DATA\n  gridSize: null,\n  map: null,\n  player: null,\n  canvas: null,\n  ctx: null,\n  // FUNCTIONS\n  init: null,\n  verifyMapDimension: null,\n  customError: null,\n  updatePlayerToMap: null,\n  update: null,\n  setGrideSize: null,\n  createPlayer: null,\n  setMap: null,\n  keydown: null,\n  drawMap: null\n};\n\nvar gridSize = 20;\n\nvar map = [\n  \"...............\",\n  \"...............\",\n  \"...............\",\n  \"...............\",\n  \"...............\",\n  \"...............\",\n  \"...............\",\n  \"#..............\",\n  \"#...MZW........\",\n  \"#..............\",\n  \"#..............\",\n  \"#..............\"\n];\n\n// Use this method of creating player objects because there will only be a single player\n//var player = {\n//  x : 8,\n//  y : 8,\n//  avatar : \"@\",\n//  color : \"orange\",\n//  lastMove : [],\n//  move : function(x,y) {\n//    // if (map[this.x+x][this.y+y] != \"#\") {\n//      this.x += x;\n//      this.y += y;\n//      game.update();\n//    // }\n//    this.lastMove = [x,y];\n//  }\n//};\n\ngame.init = function() {\n  game.canvas = document.getElementById(\"myCanvas\");\n  game.ctx = game.canvas.getContext(\"2d\");\n\n  game.ctx.font=\"17px Andale Mono\";\n  game.ctx.textAlign = \"center\";\n  game.ctx.textBaseline = \"top\";       // top means that the top of the character space\n                                    // draws at the y-coordinate you give it.\n  game.createPlayer('@', 'orange', 8, 8);\n  game.setMap(map);\n\n  game.update();\n};\n\n\ngame.createPlayer = function(avatar, color, startingX, startingY) {\n  game.player = {\n    x: startingX,\n    y: startingY,\n    avatar: avatar,\n    color: color,\n    lastMove: [],\n    move: function(x,y) {\n      // if (map[this.x+x][this.y+y] != \"#\") {\n      console.log('this in move', this);\n      this.x += x;\n      this.y += y;\n      game.update();\n      // }\n      this.lastMove = [x,y];\n    }\n  };\n};\n\ngame.setGridSize = function(size) {\n  if (game.gridSize) return;\n  game.gridSize = size;\n};\n\ngame.setMap = function(mapArray) {\n  game.map = mapArray;\n};\n\n\n//window.addEventListener(\"keydown\", function(event) {\ngame.keydown = function(event) {\n  console.log('move', event.keyCode);\n  switch(event.keyCode) {\n    case 37:\n      game.player.move(-1,0);\n      game.update();\n      break;\n    case 38:\n      game.player.move(0,-1);\n      game.update();\n      break;\n    case 39:\n      game.player.move(1,0);\n      game.update();\n      break;\n    case 40:\n      game.player.move(0,1);\n      game.update();\n      break;\n  }\n};\n\nwindow.addEventListener('keydown', game.keydown);\n\n\n// This defines a new method for array objects called drawMap. So this is the draw method\n// for whatever map is active. I could make a roguelike game dev library and include this.\n// Can optinonally include a two element color array representing the color of the map and\n// color of the grid. If I were to put this in a game library I would always need to supply\n// as a parameter the height and width of each block in the grid/map. Maybe would also need\n// optionally parameters for the x,y coords to begin drawing the map at and the height and\n// width of the map in blocks. And borderColor, if given, will give the whole map a border\n// of that color, if it is not given then there will be no border. Also need to make it so\n// it is only going through the logic of drawing what will be on screen, and not just the\n// whole map.\n// Also right now it always starts drawing at grid block (0,0), need to add two parameters\n// to represent drawing starting at a different block in the map. Could be just two params\n// at the end of the param list, but have to figure out how I keep track of it outside the\n// function.\n// The function expects a square map (or at least the first row must be as long as the\n// others).\ngame.drawMap = function(grid, colors, mapWidth, mapHeight, mapX, mapY, borderColor) {\n\n// Clear the screen for the next frame\n  game.ctx.clearRect(mapX,mapY,mapWidth*game.gridSize,mapHeight*game.gridSize);\n\n// Set default values of zero for mapX and mapY if those arguments aren't given.\n  if (typeof(mapX) === 'undefined') mapX = 0;\n  if (typeof(mapY) === 'undefined') mapY = 0;\n\n// Handle mapHeight parameter if larger than entire map or <= 0\n  mapHeight = game.verifyMapDimension(mapHeight, this.length);\n\n// Handle mapWidth parameter if larger than entire map of <= 0\n  mapWidth = game.verifyMapDimension(mapWidth, this[0].length);\n\n// Draw map to canvas\n  for (var row=0; row < (mapHeight = mapHeight || this.length); row++) {\n    for (var col=0; col < (mapWidth = mapWidth || this[row].length); col++) {\n    // output ASCII map characters\n      if (colors)\n        colors[0] ? game.ctx.fillStyle = colors[0] : game.ctx.fillStyle = \"white\";\n      else\n        game.ctx.fillStyle = \"white\";\n      // if (this[row][col].color)    // will this work?? map objects having unique colors.\n      //     game.ctx.fillStyle = this[row][col].color;\n      game.ctx.fillText(this[row][col], col*game.gridSize+(game.gridSize/2)+mapX, row*game.gridSize+mapY);\n    // output grid:\n      if (grid==true) {\n        if (colors)\n          colors[1] ? game.ctx.strokeStyle = colors[1] : game.ctx.strokeStyle = \"white\";\n        else\n          game.ctx.strokeStyle = \"white\";\n        game.ctx.strokeRect(col*game.gridSize+mapX,row*game.gridSize+mapY,game.gridSize,game.gridSize);\n      }\n    // Handle drawing (or not drawing) of map border.\n      if (borderColor) {\n        game.ctx.strokeStyle = borderColor;\n        game.ctx.strokeRect(mapX, mapY, mapWidth*game.gridSize, mapHeight*game.gridSize);\n      }\n    }\n  }\n  game.updatePlayerToMap(mapX, mapY);\n};\n\nArray.prototype.drawMap = game.drawMap;\n\n\n// Will also be in my roguelike JS game library for moving the map on screen.\ngame.moveMap = function() {\n  ;\n};\n\nArray.prototype.moveMap = game.moveMap;\n\n\n\n// Handles map width and map height display dimensions if they are bad inputs - either too\n// large (larger than map) or too small (<= 0). Fixes the dimensions or throws an error.\n// First parameter is the dimension of the map being displayed, second parameter is the map's\n// total size in that dimension.\ngame.verifyMapDimension = function(displayDimen, totalDimen) {\n  try {\n    // if mapHeight or mapWidth is given as 0 or negative, throw an error.\n    if (displayDimen <= 0)\n      throw new customError(\"Zero or negative number sent to drawMap() for viewable map dimension parameter\");\n    // if display dimension is larger than map set it equal to that of entire map\n    else if (displayDimen > totalDimen)\n      displayDimen = totalDimen;\n  } catch(err) { console.log(err); }          // print possible error to console\n  finally { return displayDimen; }\n};\n\n\n\n\n// Creating a function to call to display custom errors. Just do: throw new customError()\n// with the error message as the argument. Then send the error to the console.log() in the\n// catch block. This can also be part of my roguelike game dev library since I give the\n// errors a name appropriate to the library.\ngame.customError = function(message) {\n  this.stack = new Error().stack;\n  this.name = \"Todd Roguelike Library Error\";\n  this.message = (message || \"\");\n};\ngame.customError.prototype = new Error();//Error.prototype;\n\n// Another way of doing a custom error:\n    // function customError() {\n    //     var err = Error.apply(this,arguments);\n    //     err.name = this.name = \"Todd Library Error\";\n    //     this.stack = err.stack;\n    //     // this.message = err.message;\n    //     return this;\n    // }\n\n    // function updatePlayerToMap() {\n\n    // }\n\n// Once the player has moved this function clears from the display what is normally\n// occupying that space on the map, and outputs the player's character instead.\ngame.updatePlayerToMap = function(mapX, mapY) {//, mapWidth, mapHeight) {\n  console.log('game', game);\n  console.log(game.player.x);\n  if (game.map[game.player.x][game.player.y] != \"#\") {\n    // clear display space where player is moving to.\n    game.ctx.clearRect(game.player.x*game.gridSize+mapX, game.player.y*game.gridSize+mapY, game.gridSize, game.gridSize);\n    // output the player to the screen in the correct spot\n    game.ctx.fillStyle = game.player.color;\n    game.ctx.fillText(game.player.avatar, game.player.x*game.gridSize+(game.gridSize/2)+mapX, game.player.y*game.gridSize+mapY);\n  } else {\n    game.player.x += -game.player.lastMove[0];\n    game.player.y += -game.player.lastMove[1];\n  }\n};\n\n// Game update function (the game loop)\ngame.update = function() {\n\n  game.map.drawMap(false, [\"green\",\"blue\"], 10, 33, 100, 50);//, \"rgb(0,200,0)\");\n}\n*/\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uLi9nYW1lTGliL2luZGV4LmpzPzgxZGYiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIGxpYnJhcnkgbmVlZHMgdG8gZXhwb3NlIHB1YmxpYyBtZXRob2RzIGluaXQsIHVwZGF0ZSAobW9yZSB0byBjb21lKSBtZXRob2RzXG4gKiBsaWJyYXJ5IG5lZWRzIHRvIGV4cG9zZSBwdWJsaWMgc2V0dGVycyBsb2FkTWFwLCBzZXRUaWxlU2l6ZSwgY3JlYXRlUGxheWVyXG4gKiBsaWJyYXJ5IG5lZWRzIHRvIGV4cG9zZSBwdWJsaWMgZ2V0dGVycyBnZXRNYXAsIGdldFBsYXllciwgZ2V0Q2FudmFzPz8sIGdldENvbnRleHQ/P1xuICoga2V5cyBwcmVzc2VkLCBkcmF3TWFwLCB1cGRhdGVQbGF5ZXJUb01hcCBzaG91bGQgYmUgcnVuIG9uIHVwZGF0ZVxuKi9cblxubGV0IGdhbWUgPSB7XG4gIC8vIERBVEFcbiAgdGlsZVNpemU6IG51bGwsXG4gIG1hcDogbnVsbCxcbiAgcGxheWVyOiBudWxsLFxuICBjYW52YXM6IG51bGwsXG4gIGN0eDogbnVsbCxcbiAgLy8gRlVOQ1RJT05TXG4gIGluaXQ6IG51bGwsXG4vLyAgdmVyaWZ5TWFwRGltZW5zaW9uOiBudWxsLFxuLy8gIGN1c3RvbUVycm9yOiBudWxsLFxuLy8gIHVwZGF0ZVBsYXllclRvTWFwOiBudWxsLFxuLy8gIHVwZGF0ZTogbnVsbCxcbiAgc2V0VGlsZVNpemU6IG51bGwsXG4gIGNyZWF0ZVBsYXllcjogbnVsbCxcbiAgc2V0TWFwOiBudWxsLFxuLy8gIGtleWRvd246IG51bGwsXG4vLyAgZHJhd01hcDogbnVsbFxufTtcblxuZ2FtZS5jcmVhdGVQbGF5ZXIgPSAoYXZhdGFyLCBjb2xvciwgeCwgeSkgPT4ge1xuICBnYW1lLnBsYXllciA9IHtcbiAgICB4LFxuICAgIHksXG4gICAgYXZhdGFyLFxuICAgIGNvbG9yLFxuICAgIGxhc3RNb3ZlOiBbXSxcbiAgICBtb3ZlOiAoeCx5KSA9PiB7XG4gICAgICAvLyBpZiAobWFwW3RoaXMueCt4XVt0aGlzLnkreV0gIT0gXCIjXCIpIHtcbiAgICAgIGdhbWUucGxheWVyLnggKz0geDtcbiAgICAgIGdhbWUucGxheWVyLnkgKz0geTtcbiAgICAgIHVwZGF0ZSgpO1xuICAgICAgLy8gfVxuICAgICAgZ2FtZS5wbGF5ZXIubGFzdE1vdmUgPSBbeCx5XTtcbiAgICB9XG4gIH07XG59O1xuXG5nYW1lLnNldE1hcCA9IChtYXBBcnJheSkgPT4ge1xuICBpZiAoZ2FtZS5tYXApIHJldHVybjtcbiAgZ2FtZS5tYXAgPSBtYXBBcnJheTtcbn07XG5cbmdhbWUuc2V0VGlsZVNpemUgPSAodGlsZVNpemUpID0+IHtcbiAgaWYgKGdhbWUudGlsZVNpemUpIHJldHVybjtcbiAgZ2FtZS50aWxlU2l6ZSA9IHRpbGVTaXplO1xufTtcblxuICAgICAgICBsZXQgdGlsZVNpemUgPSAyMDtcblxuICAgICAgICBsZXQgbWFwID0gW1xuICAgICAgICAgICAgICAgIFwiLi4uLi4uLi4uLi4uLi4uXCIsXG4gICAgICAgICAgICAgICAgXCIuLi4uLi4uLi4uLi4uLi5cIixcbiAgICAgICAgICAgICAgICBcIi4uLi4uLi4uLi4uLi4uLlwiLFxuICAgICAgICAgICAgICAgIFwiLi4uLi4uLi4uLi4uLi4uXCIsXG4gICAgICAgICAgICAgICAgXCIuLi4uLi4uLi4uLi4uLi5cIixcbiAgICAgICAgICAgICAgICBcIi4uLi4uLi4uLi4uLi4uLlwiLFxuICAgICAgICAgICAgICAgIFwiLi4uLi4uLi4uLi4uLi4uXCIsXG4gICAgICAgICAgICAgICAgXCIjLi4uLi4uLi4uLi4uLi5cIixcbiAgICAgICAgICAgICAgICBcIiMuLi5NWlcuLi4uLi4uLlwiLFxuICAgICAgICAgICAgICAgIFwiIy4uLi4uLi4uLi4uLi4uXCIsXG4gICAgICAgICAgICAgICAgXCIjLi4uLi4uLi4uLi4uLi5cIixcbiAgICAgICAgICAgICAgICBcIiMuLi4uLi4uLi4uLi4uLlwiXG4gICAgICAgICAgICAgICAgXTtcblxuXG4gICAgLy8gVXNlIHRoaXMgbWV0aG9kIG9mIGNyZWF0aW5nIHBsYXllciBvYmplY3RzIGJlY2F1c2UgdGhlcmUgd2lsbCBvbmx5IGJlIGEgc2luZ2xlIHBsYXllclxuICAgICAgICAvKnZhciBwbGF5ZXIgPSB7XG4gICAgICAgICAgICB4IDogOCxcbiAgICAgICAgICAgIHkgOiA4LFxuICAgICAgICAgICAgYXZhdGFyIDogXCJAXCIsXG4gICAgICAgICAgICBjb2xvciA6IFwib3JhbmdlXCIsXG4gICAgICAgICAgICBsYXN0TW92ZSA6IFtdLFxuICAgICAgICAgICAgbW92ZSA6IGZ1bmN0aW9uKHgseSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIChtYXBbdGhpcy54K3hdW3RoaXMueSt5XSAhPSBcIiNcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnggKz0geDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ICs9IHk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RNb3ZlID0gW3gseV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07Ki9cblxuXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaChldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAzNzpcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5wbGF5ZXIubW92ZSgtMSwwKTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgICAgICAgICAgIGdhbWUucGxheWVyLm1vdmUoMCwtMSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM5OlxuICAgICAgICAgICAgICAgICAgICBnYW1lLnBsYXllci5tb3ZlKDEsMCk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgICAgICAgICAgICBnYW1lLnBsYXllci5tb3ZlKDAsMSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZ2FtZS5pbml0ID0gKCkgPT4ge1xuICAgICAgICAgICAgZ2FtZS5jYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm15Q2FudmFzXCIpO1xuICAgICAgICAgICAgZ2FtZS5jYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgICAgIGdhbWUuY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICAgICAgICAgIGdhbWUuY3R4ID0gZ2FtZS5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgICAgICBnYW1lLmN0eC5mb250PVwiMTdweCBBbmRhbGUgTW9ub1wiO1xuICAgICAgICAgICAgZ2FtZS5jdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgICAgICAgICAgIGdhbWUuY3R4LnRleHRCYXNlbGluZSA9IFwidG9wXCI7ICAgICAgIC8vIHRvcCBtZWFucyB0aGF0IHRoZSB0b3Agb2YgdGhlIGNoYXJhY3RlciBzcGFjZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3cyBhdCB0aGUgeS1jb29yZGluYXRlIHlvdSBnaXZlIGl0LlxuICAgICAgICAgICAgZ2FtZS5jcmVhdGVQbGF5ZXIoJ0AnLCAnb3JhbmdlJywgOCwgOCk7XG4gICAgICAgICAgICBnYW1lLnNldFRpbGVTaXplKHRpbGVTaXplKTtcbiAgICAgICAgICAgIGdhbWUuc2V0TWFwKG1hcCk7XG4gICAgICAgICAgICB1cGRhdGUoKTtcblxuICAgICAgICB9O1xuXG4gICAgLy8gVGhpcyBkZWZpbmVzIGEgbmV3IG1ldGhvZCBmb3IgYXJyYXkgb2JqZWN0cyBjYWxsZWQgZHJhd01hcC4gU28gdGhpcyBpcyB0aGUgZHJhdyBtZXRob2RcbiAgICAvLyBmb3Igd2hhdGV2ZXIgbWFwIGlzIGFjdGl2ZS4gSSBjb3VsZCBtYWtlIGEgcm9ndWVsaWtlIGdhbWUgZGV2IGxpYnJhcnkgYW5kIGluY2x1ZGUgdGhpcy5cbiAgICAvLyBDYW4gb3B0aW5vbmFsbHkgaW5jbHVkZSBhIHR3byBlbGVtZW50IGNvbG9yIGFycmF5IHJlcHJlc2VudGluZyB0aGUgY29sb3Igb2YgdGhlIG1hcCBhbmRcbiAgICAvLyBjb2xvciBvZiB0aGUgZ3JpZC4gSWYgSSB3ZXJlIHRvIHB1dCB0aGlzIGluIGEgZ2FtZSBsaWJyYXJ5IEkgd291bGQgYWx3YXlzIG5lZWQgdG8gc3VwcGx5XG4gICAgLy8gYXMgYSBwYXJhbWV0ZXIgdGhlIGhlaWdodCBhbmQgd2lkdGggb2YgZWFjaCBibG9jayBpbiB0aGUgZ3JpZC9tYXAuIE1heWJlIHdvdWxkIGFsc28gbmVlZFxuICAgIC8vIG9wdGlvbmFsbHkgcGFyYW1ldGVycyBmb3IgdGhlIHgseSBjb29yZHMgdG8gYmVnaW4gZHJhd2luZyB0aGUgbWFwIGF0IGFuZCB0aGUgaGVpZ2h0IGFuZFxuICAgIC8vIHdpZHRoIG9mIHRoZSBtYXAgaW4gYmxvY2tzLiBBbmQgYm9yZGVyQ29sb3IsIGlmIGdpdmVuLCB3aWxsIGdpdmUgdGhlIHdob2xlIG1hcCBhIGJvcmRlclxuICAgIC8vIG9mIHRoYXQgY29sb3IsIGlmIGl0IGlzIG5vdCBnaXZlbiB0aGVuIHRoZXJlIHdpbGwgYmUgbm8gYm9yZGVyLiBBbHNvIG5lZWQgdG8gbWFrZSBpdCBzb1xuICAgIC8vIGl0IGlzIG9ubHkgZ29pbmcgdGhyb3VnaCB0aGUgbG9naWMgb2YgZHJhd2luZyB3aGF0IHdpbGwgYmUgb24gc2NyZWVuLCBhbmQgbm90IGp1c3QgdGhlXG4gICAgLy8gd2hvbGUgbWFwLlxuICAgIC8vIEFsc28gcmlnaHQgbm93IGl0IGFsd2F5cyBzdGFydHMgZHJhd2luZyBhdCBncmlkIGJsb2NrICgwLDApLCBuZWVkIHRvIGFkZCB0d28gcGFyYW1ldGVyc1xuICAgIC8vIHRvIHJlcHJlc2VudCBkcmF3aW5nIHN0YXJ0aW5nIGF0IGEgZGlmZmVyZW50IGJsb2NrIGluIHRoZSBtYXAuIENvdWxkIGJlIGp1c3QgdHdvIHBhcmFtc1xuICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhlIHBhcmFtIGxpc3QsIGJ1dCBoYXZlIHRvIGZpZ3VyZSBvdXQgaG93IEkga2VlcCB0cmFjayBvZiBpdCBvdXRzaWRlIHRoZVxuICAgIC8vIGZ1bmN0aW9uLlxuICAgIC8vIFRoZSBmdW5jdGlvbiBleHBlY3RzIGEgc3F1YXJlIG1hcCAob3IgYXQgbGVhc3QgdGhlIGZpcnN0IHJvdyBtdXN0IGJlIGFzIGxvbmcgYXMgdGhlXG4gICAgLy8gb3RoZXJzKS5cbiAgICAgICAgQXJyYXkucHJvdG90eXBlLmRyYXdNYXAgPSBmdW5jdGlvbihncmlkLCBjb2xvcnMsIG1hcFdpZHRoLCBtYXBIZWlnaHQsIG1hcFgsIG1hcFksIGJvcmRlckNvbG9yKSB7XG5cbiAgICAgICAgLy8gQ2xlYXIgdGhlIHNjcmVlbiBmb3IgdGhlIG5leHQgZnJhbWVcbiAgICAgICAgICAgIGdhbWUuY3R4LmNsZWFyUmVjdChtYXBYLG1hcFksbWFwV2lkdGgqdGlsZVNpemUsbWFwSGVpZ2h0KnRpbGVTaXplKTtcblxuICAgICAgICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgb2YgemVybyBmb3IgbWFwWCBhbmQgbWFwWSBpZiB0aG9zZSBhcmd1bWVudHMgYXJlbid0IGdpdmVuLlxuICAgICAgICAgICAgaWYgKHR5cGVvZihtYXBYKSA9PT0gJ3VuZGVmaW5lZCcpIG1hcFggPSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihtYXBZKSA9PT0gJ3VuZGVmaW5lZCcpIG1hcFkgPSAwO1xuXG4gICAgICAgIC8vIEhhbmRsZSBtYXBIZWlnaHQgcGFyYW1ldGVyIGlmIGxhcmdlciB0aGFuIGVudGlyZSBtYXAgb3IgPD0gMFxuICAgICAgICAgICAgbWFwSGVpZ2h0ID0gdmVyaWZ5TWFwRGltZW5zaW9uKG1hcEhlaWdodCwgdGhpcy5sZW5ndGgpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBtYXBXaWR0aCBwYXJhbWV0ZXIgaWYgbGFyZ2VyIHRoYW4gZW50aXJlIG1hcCBvZiA8PSAwXG4gICAgICAgICAgICBtYXBXaWR0aCA9IHZlcmlmeU1hcERpbWVuc2lvbihtYXBXaWR0aCwgdGhpc1swXS5sZW5ndGgpO1xuXG4gICAgICAgIC8vIERyYXcgbWFwIHRvIGNhbnZhc1xuICAgICAgICAgICAgZm9yIChsZXQgcm93PTA7IHJvdyA8IChtYXBIZWlnaHQgPSBtYXBIZWlnaHQgfHwgdGhpcy5sZW5ndGgpOyByb3crKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbD0wOyBjb2wgPCAobWFwV2lkdGggPSBtYXBXaWR0aCB8fCB0aGlzW3Jvd10ubGVuZ3RoKTsgY29sKyspIHtcbiAgICAgICAgICAgICAgICAvLyBvdXRwdXQgQVNDSUkgbWFwIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yc1swXSA/IGdhbWUuY3R4LmZpbGxTdHlsZSA9IGNvbG9yc1swXSA6IGdhbWUuY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2FtZS5jdHguZmlsbFN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAodGhpc1tyb3ddW2NvbF0uY29sb3IpICAgIC8vIHdpbGwgdGhpcyB3b3JrPz8gbWFwIG9iamVjdHMgaGF2aW5nIHVuaXF1ZSBjb2xvcnMuXG4gICAgICAgICAgICAgICAgICAgIC8vICAgICBnYW1lLmN0eC5maWxsU3R5bGUgPSB0aGlzW3Jvd11bY29sXS5jb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgZ2FtZS5jdHguZmlsbFRleHQodGhpc1tyb3ddW2NvbF0sIGNvbCp0aWxlU2l6ZSsodGlsZVNpemUvMikrbWFwWCwgcm93KnRpbGVTaXplK21hcFkpO1xuICAgICAgICAgICAgICAgIC8vIG91dHB1dCBncmlkOlxuICAgICAgICAgICAgICAgICAgICBpZiAoZ3JpZD09dHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbG9ycylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcnNbMV0gPyBnYW1lLmN0eC5zdHJva2VTdHlsZSA9IGNvbG9yc1sxXSA6IGdhbWUuY3R4LnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhbWUuY3R4LnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2FtZS5jdHguc3Ryb2tlUmVjdChjb2wqdGlsZVNpemUrbWFwWCxyb3cqdGlsZVNpemUrbWFwWSx0aWxlU2l6ZSx0aWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZHJhd2luZyAob3Igbm90IGRyYXdpbmcpIG9mIG1hcCBib3JkZXIuXG4gICAgICAgICAgICAgICAgICAgIGlmIChib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2FtZS5jdHguc3Ryb2tlU3R5bGUgPSBib3JkZXJDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdhbWUuY3R4LnN0cm9rZVJlY3QobWFwWCwgbWFwWSwgbWFwV2lkdGgqdGlsZVNpemUsIG1hcEhlaWdodCp0aWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGVQbGF5ZXJUb01hcChtYXBYLCBtYXBZKTtcbiAgICAgICAgfVxuXG5cbiAgICAvLyBXaWxsIGFsc28gYmUgaW4gbXkgcm9ndWVsaWtlIEpTIGdhbWUgbGlicmFyeSBmb3IgbW92aW5nIHRoZSBtYXAgb24gc2NyZWVuLlxuICAgICAgICBBcnJheS5wcm90b3R5cGUubW92ZU1hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgO1xuICAgICAgICB9XG5cblxuXG4gICAgLy8gSGFuZGxlcyBtYXAgd2lkdGggYW5kIG1hcCBoZWlnaHQgZGlzcGxheSBkaW1lbnNpb25zIGlmIHRoZXkgYXJlIGJhZCBpbnB1dHMgLSBlaXRoZXIgdG9vXG4gICAgLy8gbGFyZ2UgKGxhcmdlciB0aGFuIG1hcCkgb3IgdG9vIHNtYWxsICg8PSAwKS4gRml4ZXMgdGhlIGRpbWVuc2lvbnMgb3IgdGhyb3dzIGFuIGVycm9yLlxuICAgIC8vIEZpcnN0IHBhcmFtZXRlciBpcyB0aGUgZGltZW5zaW9uIG9mIHRoZSBtYXAgYmVpbmcgZGlzcGxheWVkLCBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBtYXAnc1xuICAgIC8vIHRvdGFsIHNpemUgaW4gdGhhdCBkaW1lbnNpb24uXG4gICAgICAgIGZ1bmN0aW9uIHZlcmlmeU1hcERpbWVuc2lvbihkaXNwbGF5RGltZW4sIHRvdGFsRGltZW4pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgbWFwSGVpZ2h0IG9yIG1hcFdpZHRoIGlzIGdpdmVuIGFzIDAgb3IgbmVnYXRpdmUsIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgICAgIGlmIChkaXNwbGF5RGltZW4gPD0gMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGN1c3RvbUVycm9yKFwiWmVybyBvciBuZWdhdGl2ZSBudW1iZXIgc2VudCB0byBkcmF3TWFwKCkgZm9yIHZpZXdhYmxlIG1hcCBkaW1lbnNpb24gcGFyYW1ldGVyXCIpO1xuICAgICAgICAgICAgICAgIC8vIGlmIGRpc3BsYXkgZGltZW5zaW9uIGlzIGxhcmdlciB0aGFuIG1hcCBzZXQgaXQgZXF1YWwgdG8gdGhhdCBvZiBlbnRpcmUgbWFwXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZGlzcGxheURpbWVuID4gdG90YWxEaW1lbilcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheURpbWVuID0gdG90YWxEaW1lbjtcbiAgICAgICAgICAgIH0gY2F0Y2goZXJyKSB7IGNvbnNvbGUubG9nKGVycik7IH0gICAgICAgICAgLy8gcHJpbnQgcG9zc2libGUgZXJyb3IgdG8gY29uc29sZVxuICAgICAgICAgICAgZmluYWxseSB7IHJldHVybiBkaXNwbGF5RGltZW47IH1cbiAgICAgICAgfVxuXG5cblxuXG4gICAgLy8gQ3JlYXRpbmcgYSBmdW5jdGlvbiB0byBjYWxsIHRvIGRpc3BsYXkgY3VzdG9tIGVycm9ycy4gSnVzdCBkbzogdGhyb3cgbmV3IGN1c3RvbUVycm9yKClcbiAgICAvLyB3aXRoIHRoZSBlcnJvciBtZXNzYWdlIGFzIHRoZSBhcmd1bWVudC4gVGhlbiBzZW5kIHRoZSBlcnJvciB0byB0aGUgY29uc29sZS5sb2coKSBpbiB0aGVcbiAgICAvLyBjYXRjaCBibG9jay4gVGhpcyBjYW4gYWxzbyBiZSBwYXJ0IG9mIG15IHJvZ3VlbGlrZSBnYW1lIGRldiBsaWJyYXJ5IHNpbmNlIEkgZ2l2ZSB0aGVcbiAgICAvLyBlcnJvcnMgYSBuYW1lIGFwcHJvcHJpYXRlIHRvIHRoZSBsaWJyYXJ5LlxuICAgICAgICBmdW5jdGlvbiBjdXN0b21FcnJvcihtZXNzYWdlKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBcIlRvZGQgUm9ndWVsaWtlIExpYnJhcnkgRXJyb3JcIjtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IChtZXNzYWdlIHx8IFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGN1c3RvbUVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpOy8vRXJyb3IucHJvdG90eXBlO1xuXG4gICAgLy8gQW5vdGhlciB3YXkgb2YgZG9pbmcgYSBjdXN0b20gZXJyb3I6XG4gICAgICAgIC8vIGZ1bmN0aW9uIGN1c3RvbUVycm9yKCkge1xuICAgICAgICAvLyAgICAgbGV0IGVyciA9IEVycm9yLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcbiAgICAgICAgLy8gICAgIGVyci5uYW1lID0gdGhpcy5uYW1lID0gXCJUb2RkIExpYnJhcnkgRXJyb3JcIjtcbiAgICAgICAgLy8gICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgICAgIC8vICAgICAvLyB0aGlzLm1lc3NhZ2UgPSBlcnIubWVzc2FnZTtcbiAgICAgICAgLy8gICAgIHJldHVybiB0aGlzO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gZnVuY3Rpb24gdXBkYXRlUGxheWVyVG9NYXAoKSB7XG5cbiAgICAgICAgLy8gfVxuXG4gICAgLy8gT25jZSB0aGUgcGxheWVyIGhhcyBtb3ZlZCB0aGlzIGZ1bmN0aW9uIGNsZWFycyBmcm9tIHRoZSBkaXNwbGF5IHdoYXQgaXMgbm9ybWFsbHlcbiAgICAvLyBvY2N1cHlpbmcgdGhhdCBzcGFjZSBvbiB0aGUgbWFwLCBhbmQgb3V0cHV0cyB0aGUgcGxheWVyJ3MgY2hhcmFjdGVyIGluc3RlYWQuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVBsYXllclRvTWFwKG1hcFgsIG1hcFkpIHsvLywgbWFwV2lkdGgsIG1hcEhlaWdodCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZ2FtZS5wbGF5ZXIueCk7XG4gICAgICAgICAgICBpZiAoZ2FtZS5tYXBbZ2FtZS5wbGF5ZXIueF1bZ2FtZS5wbGF5ZXIueV0gIT0gXCIjXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGVhciBkaXNwbGF5IHNwYWNlIHdoZXJlIHBsYXllciBpcyBtb3ZpbmcgdG8uXG4gICAgICAgICAgICAgICAgZ2FtZS5jdHguY2xlYXJSZWN0KGdhbWUucGxheWVyLngqdGlsZVNpemUrbWFwWCwgZ2FtZS5wbGF5ZXIueSp0aWxlU2l6ZSttYXBZLCB0aWxlU2l6ZSwgdGlsZVNpemUpO1xuICAgICAgICAgICAgICAgIC8vIG91dHB1dCB0aGUgcGxheWVyIHRvIHRoZSBzY3JlZW4gaW4gdGhlIGNvcnJlY3Qgc3BvdFxuICAgICAgICAgICAgICAgIGdhbWUuY3R4LmZpbGxTdHlsZSA9IGdhbWUucGxheWVyLmNvbG9yO1xuICAgICAgICAgICAgICAgIGdhbWUuY3R4LmZpbGxUZXh0KGdhbWUucGxheWVyLmF2YXRhciwgZ2FtZS5wbGF5ZXIueCp0aWxlU2l6ZSsodGlsZVNpemUvMikrbWFwWCwgZ2FtZS5wbGF5ZXIueSp0aWxlU2l6ZSttYXBZKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2FtZS5wbGF5ZXIueCArPSAtZ2FtZS5wbGF5ZXIubGFzdE1vdmVbMF07XG4gICAgICAgICAgICAgICAgZ2FtZS5wbGF5ZXIueSArPSAtZ2FtZS5wbGF5ZXIubGFzdE1vdmVbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgIC8vIEdhbWUgdXBkYXRlIGZ1bmN0aW9uICh0aGUgZ2FtZSBsb29wKVxuICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cbiAgICAgICAgICAgIGdhbWUubWFwLmRyYXdNYXAoZmFsc2UsIFtcImdyZWVuXCIsXCJibHVlXCJdLCAxMCwgMzMsIDEwMCwgNTApOy8vLCBcInJnYigwLDIwMCwwKVwiKTtcbiAgICAgICAgfVxuXG5cblxuZXhwb3J0IGRlZmF1bHQgZ2FtZTtcblxuXG5cblxuXG5cbi8qXG52YXIgZ2FtZSA9IHtcbiAgLy8gREFUQVxuICBncmlkU2l6ZTogbnVsbCxcbiAgbWFwOiBudWxsLFxuICBwbGF5ZXI6IG51bGwsXG4gIGNhbnZhczogbnVsbCxcbiAgY3R4OiBudWxsLFxuICAvLyBGVU5DVElPTlNcbiAgaW5pdDogbnVsbCxcbiAgdmVyaWZ5TWFwRGltZW5zaW9uOiBudWxsLFxuICBjdXN0b21FcnJvcjogbnVsbCxcbiAgdXBkYXRlUGxheWVyVG9NYXA6IG51bGwsXG4gIHVwZGF0ZTogbnVsbCxcbiAgc2V0R3JpZGVTaXplOiBudWxsLFxuICBjcmVhdGVQbGF5ZXI6IG51bGwsXG4gIHNldE1hcDogbnVsbCxcbiAga2V5ZG93bjogbnVsbCxcbiAgZHJhd01hcDogbnVsbFxufTtcblxudmFyIGdyaWRTaXplID0gMjA7XG5cbnZhciBtYXAgPSBbXG4gIFwiLi4uLi4uLi4uLi4uLi4uXCIsXG4gIFwiLi4uLi4uLi4uLi4uLi4uXCIsXG4gIFwiLi4uLi4uLi4uLi4uLi4uXCIsXG4gIFwiLi4uLi4uLi4uLi4uLi4uXCIsXG4gIFwiLi4uLi4uLi4uLi4uLi4uXCIsXG4gIFwiLi4uLi4uLi4uLi4uLi4uXCIsXG4gIFwiLi4uLi4uLi4uLi4uLi4uXCIsXG4gIFwiIy4uLi4uLi4uLi4uLi4uXCIsXG4gIFwiIy4uLk1aVy4uLi4uLi4uXCIsXG4gIFwiIy4uLi4uLi4uLi4uLi4uXCIsXG4gIFwiIy4uLi4uLi4uLi4uLi4uXCIsXG4gIFwiIy4uLi4uLi4uLi4uLi4uXCJcbl07XG5cbi8vIFVzZSB0aGlzIG1ldGhvZCBvZiBjcmVhdGluZyBwbGF5ZXIgb2JqZWN0cyBiZWNhdXNlIHRoZXJlIHdpbGwgb25seSBiZSBhIHNpbmdsZSBwbGF5ZXJcbi8vdmFyIHBsYXllciA9IHtcbi8vICB4IDogOCxcbi8vICB5IDogOCxcbi8vICBhdmF0YXIgOiBcIkBcIixcbi8vICBjb2xvciA6IFwib3JhbmdlXCIsXG4vLyAgbGFzdE1vdmUgOiBbXSxcbi8vICBtb3ZlIDogZnVuY3Rpb24oeCx5KSB7XG4vLyAgICAvLyBpZiAobWFwW3RoaXMueCt4XVt0aGlzLnkreV0gIT0gXCIjXCIpIHtcbi8vICAgICAgdGhpcy54ICs9IHg7XG4vLyAgICAgIHRoaXMueSArPSB5O1xuLy8gICAgICBnYW1lLnVwZGF0ZSgpO1xuLy8gICAgLy8gfVxuLy8gICAgdGhpcy5sYXN0TW92ZSA9IFt4LHldO1xuLy8gIH1cbi8vfTtcblxuZ2FtZS5pbml0ID0gZnVuY3Rpb24oKSB7XG4gIGdhbWUuY2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJteUNhbnZhc1wiKTtcbiAgZ2FtZS5jdHggPSBnYW1lLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgZ2FtZS5jdHguZm9udD1cIjE3cHggQW5kYWxlIE1vbm9cIjtcbiAgZ2FtZS5jdHgudGV4dEFsaWduID0gXCJjZW50ZXJcIjtcbiAgZ2FtZS5jdHgudGV4dEJhc2VsaW5lID0gXCJ0b3BcIjsgICAgICAgLy8gdG9wIG1lYW5zIHRoYXQgdGhlIHRvcCBvZiB0aGUgY2hhcmFjdGVyIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkcmF3cyBhdCB0aGUgeS1jb29yZGluYXRlIHlvdSBnaXZlIGl0LlxuICBnYW1lLmNyZWF0ZVBsYXllcignQCcsICdvcmFuZ2UnLCA4LCA4KTtcbiAgZ2FtZS5zZXRNYXAobWFwKTtcblxuICBnYW1lLnVwZGF0ZSgpO1xufTtcblxuXG5nYW1lLmNyZWF0ZVBsYXllciA9IGZ1bmN0aW9uKGF2YXRhciwgY29sb3IsIHN0YXJ0aW5nWCwgc3RhcnRpbmdZKSB7XG4gIGdhbWUucGxheWVyID0ge1xuICAgIHg6IHN0YXJ0aW5nWCxcbiAgICB5OiBzdGFydGluZ1ksXG4gICAgYXZhdGFyOiBhdmF0YXIsXG4gICAgY29sb3I6IGNvbG9yLFxuICAgIGxhc3RNb3ZlOiBbXSxcbiAgICBtb3ZlOiBmdW5jdGlvbih4LHkpIHtcbiAgICAgIC8vIGlmIChtYXBbdGhpcy54K3hdW3RoaXMueSt5XSAhPSBcIiNcIikge1xuICAgICAgY29uc29sZS5sb2coJ3RoaXMgaW4gbW92ZScsIHRoaXMpO1xuICAgICAgdGhpcy54ICs9IHg7XG4gICAgICB0aGlzLnkgKz0geTtcbiAgICAgIGdhbWUudXBkYXRlKCk7XG4gICAgICAvLyB9XG4gICAgICB0aGlzLmxhc3RNb3ZlID0gW3gseV07XG4gICAgfVxuICB9O1xufTtcblxuZ2FtZS5zZXRHcmlkU2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgaWYgKGdhbWUuZ3JpZFNpemUpIHJldHVybjtcbiAgZ2FtZS5ncmlkU2l6ZSA9IHNpemU7XG59O1xuXG5nYW1lLnNldE1hcCA9IGZ1bmN0aW9uKG1hcEFycmF5KSB7XG4gIGdhbWUubWFwID0gbWFwQXJyYXk7XG59O1xuXG5cbi8vd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIGZ1bmN0aW9uKGV2ZW50KSB7XG5nYW1lLmtleWRvd24gPSBmdW5jdGlvbihldmVudCkge1xuICBjb25zb2xlLmxvZygnbW92ZScsIGV2ZW50LmtleUNvZGUpO1xuICBzd2l0Y2goZXZlbnQua2V5Q29kZSkge1xuICAgIGNhc2UgMzc6XG4gICAgICBnYW1lLnBsYXllci5tb3ZlKC0xLDApO1xuICAgICAgZ2FtZS51cGRhdGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzg6XG4gICAgICBnYW1lLnBsYXllci5tb3ZlKDAsLTEpO1xuICAgICAgZ2FtZS51cGRhdGUoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMzk6XG4gICAgICBnYW1lLnBsYXllci5tb3ZlKDEsMCk7XG4gICAgICBnYW1lLnVwZGF0ZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSA0MDpcbiAgICAgIGdhbWUucGxheWVyLm1vdmUoMCwxKTtcbiAgICAgIGdhbWUudXBkYXRlKCk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBnYW1lLmtleWRvd24pO1xuXG5cbi8vIFRoaXMgZGVmaW5lcyBhIG5ldyBtZXRob2QgZm9yIGFycmF5IG9iamVjdHMgY2FsbGVkIGRyYXdNYXAuIFNvIHRoaXMgaXMgdGhlIGRyYXcgbWV0aG9kXG4vLyBmb3Igd2hhdGV2ZXIgbWFwIGlzIGFjdGl2ZS4gSSBjb3VsZCBtYWtlIGEgcm9ndWVsaWtlIGdhbWUgZGV2IGxpYnJhcnkgYW5kIGluY2x1ZGUgdGhpcy5cbi8vIENhbiBvcHRpbm9uYWxseSBpbmNsdWRlIGEgdHdvIGVsZW1lbnQgY29sb3IgYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBjb2xvciBvZiB0aGUgbWFwIGFuZFxuLy8gY29sb3Igb2YgdGhlIGdyaWQuIElmIEkgd2VyZSB0byBwdXQgdGhpcyBpbiBhIGdhbWUgbGlicmFyeSBJIHdvdWxkIGFsd2F5cyBuZWVkIHRvIHN1cHBseVxuLy8gYXMgYSBwYXJhbWV0ZXIgdGhlIGhlaWdodCBhbmQgd2lkdGggb2YgZWFjaCBibG9jayBpbiB0aGUgZ3JpZC9tYXAuIE1heWJlIHdvdWxkIGFsc28gbmVlZFxuLy8gb3B0aW9uYWxseSBwYXJhbWV0ZXJzIGZvciB0aGUgeCx5IGNvb3JkcyB0byBiZWdpbiBkcmF3aW5nIHRoZSBtYXAgYXQgYW5kIHRoZSBoZWlnaHQgYW5kXG4vLyB3aWR0aCBvZiB0aGUgbWFwIGluIGJsb2Nrcy4gQW5kIGJvcmRlckNvbG9yLCBpZiBnaXZlbiwgd2lsbCBnaXZlIHRoZSB3aG9sZSBtYXAgYSBib3JkZXJcbi8vIG9mIHRoYXQgY29sb3IsIGlmIGl0IGlzIG5vdCBnaXZlbiB0aGVuIHRoZXJlIHdpbGwgYmUgbm8gYm9yZGVyLiBBbHNvIG5lZWQgdG8gbWFrZSBpdCBzb1xuLy8gaXQgaXMgb25seSBnb2luZyB0aHJvdWdoIHRoZSBsb2dpYyBvZiBkcmF3aW5nIHdoYXQgd2lsbCBiZSBvbiBzY3JlZW4sIGFuZCBub3QganVzdCB0aGVcbi8vIHdob2xlIG1hcC5cbi8vIEFsc28gcmlnaHQgbm93IGl0IGFsd2F5cyBzdGFydHMgZHJhd2luZyBhdCBncmlkIGJsb2NrICgwLDApLCBuZWVkIHRvIGFkZCB0d28gcGFyYW1ldGVyc1xuLy8gdG8gcmVwcmVzZW50IGRyYXdpbmcgc3RhcnRpbmcgYXQgYSBkaWZmZXJlbnQgYmxvY2sgaW4gdGhlIG1hcC4gQ291bGQgYmUganVzdCB0d28gcGFyYW1zXG4vLyBhdCB0aGUgZW5kIG9mIHRoZSBwYXJhbSBsaXN0LCBidXQgaGF2ZSB0byBmaWd1cmUgb3V0IGhvdyBJIGtlZXAgdHJhY2sgb2YgaXQgb3V0c2lkZSB0aGVcbi8vIGZ1bmN0aW9uLlxuLy8gVGhlIGZ1bmN0aW9uIGV4cGVjdHMgYSBzcXVhcmUgbWFwIChvciBhdCBsZWFzdCB0aGUgZmlyc3Qgcm93IG11c3QgYmUgYXMgbG9uZyBhcyB0aGVcbi8vIG90aGVycykuXG5nYW1lLmRyYXdNYXAgPSBmdW5jdGlvbihncmlkLCBjb2xvcnMsIG1hcFdpZHRoLCBtYXBIZWlnaHQsIG1hcFgsIG1hcFksIGJvcmRlckNvbG9yKSB7XG5cbi8vIENsZWFyIHRoZSBzY3JlZW4gZm9yIHRoZSBuZXh0IGZyYW1lXG4gIGdhbWUuY3R4LmNsZWFyUmVjdChtYXBYLG1hcFksbWFwV2lkdGgqZ2FtZS5ncmlkU2l6ZSxtYXBIZWlnaHQqZ2FtZS5ncmlkU2l6ZSk7XG5cbi8vIFNldCBkZWZhdWx0IHZhbHVlcyBvZiB6ZXJvIGZvciBtYXBYIGFuZCBtYXBZIGlmIHRob3NlIGFyZ3VtZW50cyBhcmVuJ3QgZ2l2ZW4uXG4gIGlmICh0eXBlb2YobWFwWCkgPT09ICd1bmRlZmluZWQnKSBtYXBYID0gMDtcbiAgaWYgKHR5cGVvZihtYXBZKSA9PT0gJ3VuZGVmaW5lZCcpIG1hcFkgPSAwO1xuXG4vLyBIYW5kbGUgbWFwSGVpZ2h0IHBhcmFtZXRlciBpZiBsYXJnZXIgdGhhbiBlbnRpcmUgbWFwIG9yIDw9IDBcbiAgbWFwSGVpZ2h0ID0gZ2FtZS52ZXJpZnlNYXBEaW1lbnNpb24obWFwSGVpZ2h0LCB0aGlzLmxlbmd0aCk7XG5cbi8vIEhhbmRsZSBtYXBXaWR0aCBwYXJhbWV0ZXIgaWYgbGFyZ2VyIHRoYW4gZW50aXJlIG1hcCBvZiA8PSAwXG4gIG1hcFdpZHRoID0gZ2FtZS52ZXJpZnlNYXBEaW1lbnNpb24obWFwV2lkdGgsIHRoaXNbMF0ubGVuZ3RoKTtcblxuLy8gRHJhdyBtYXAgdG8gY2FudmFzXG4gIGZvciAodmFyIHJvdz0wOyByb3cgPCAobWFwSGVpZ2h0ID0gbWFwSGVpZ2h0IHx8IHRoaXMubGVuZ3RoKTsgcm93KyspIHtcbiAgICBmb3IgKHZhciBjb2w9MDsgY29sIDwgKG1hcFdpZHRoID0gbWFwV2lkdGggfHwgdGhpc1tyb3ddLmxlbmd0aCk7IGNvbCsrKSB7XG4gICAgLy8gb3V0cHV0IEFTQ0lJIG1hcCBjaGFyYWN0ZXJzXG4gICAgICBpZiAoY29sb3JzKVxuICAgICAgICBjb2xvcnNbMF0gPyBnYW1lLmN0eC5maWxsU3R5bGUgPSBjb2xvcnNbMF0gOiBnYW1lLmN0eC5maWxsU3R5bGUgPSBcIndoaXRlXCI7XG4gICAgICBlbHNlXG4gICAgICAgIGdhbWUuY3R4LmZpbGxTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgIC8vIGlmICh0aGlzW3Jvd11bY29sXS5jb2xvcikgICAgLy8gd2lsbCB0aGlzIHdvcms/PyBtYXAgb2JqZWN0cyBoYXZpbmcgdW5pcXVlIGNvbG9ycy5cbiAgICAgIC8vICAgICBnYW1lLmN0eC5maWxsU3R5bGUgPSB0aGlzW3Jvd11bY29sXS5jb2xvcjtcbiAgICAgIGdhbWUuY3R4LmZpbGxUZXh0KHRoaXNbcm93XVtjb2xdLCBjb2wqZ2FtZS5ncmlkU2l6ZSsoZ2FtZS5ncmlkU2l6ZS8yKSttYXBYLCByb3cqZ2FtZS5ncmlkU2l6ZSttYXBZKTtcbiAgICAvLyBvdXRwdXQgZ3JpZDpcbiAgICAgIGlmIChncmlkPT10cnVlKSB7XG4gICAgICAgIGlmIChjb2xvcnMpXG4gICAgICAgICAgY29sb3JzWzFdID8gZ2FtZS5jdHguc3Ryb2tlU3R5bGUgPSBjb2xvcnNbMV0gOiBnYW1lLmN0eC5zdHJva2VTdHlsZSA9IFwid2hpdGVcIjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGdhbWUuY3R4LnN0cm9rZVN0eWxlID0gXCJ3aGl0ZVwiO1xuICAgICAgICBnYW1lLmN0eC5zdHJva2VSZWN0KGNvbCpnYW1lLmdyaWRTaXplK21hcFgscm93KmdhbWUuZ3JpZFNpemUrbWFwWSxnYW1lLmdyaWRTaXplLGdhbWUuZ3JpZFNpemUpO1xuICAgICAgfVxuICAgIC8vIEhhbmRsZSBkcmF3aW5nIChvciBub3QgZHJhd2luZykgb2YgbWFwIGJvcmRlci5cbiAgICAgIGlmIChib3JkZXJDb2xvcikge1xuICAgICAgICBnYW1lLmN0eC5zdHJva2VTdHlsZSA9IGJvcmRlckNvbG9yO1xuICAgICAgICBnYW1lLmN0eC5zdHJva2VSZWN0KG1hcFgsIG1hcFksIG1hcFdpZHRoKmdhbWUuZ3JpZFNpemUsIG1hcEhlaWdodCpnYW1lLmdyaWRTaXplKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2FtZS51cGRhdGVQbGF5ZXJUb01hcChtYXBYLCBtYXBZKTtcbn07XG5cbkFycmF5LnByb3RvdHlwZS5kcmF3TWFwID0gZ2FtZS5kcmF3TWFwO1xuXG5cbi8vIFdpbGwgYWxzbyBiZSBpbiBteSByb2d1ZWxpa2UgSlMgZ2FtZSBsaWJyYXJ5IGZvciBtb3ZpbmcgdGhlIG1hcCBvbiBzY3JlZW4uXG5nYW1lLm1vdmVNYXAgPSBmdW5jdGlvbigpIHtcbiAgO1xufTtcblxuQXJyYXkucHJvdG90eXBlLm1vdmVNYXAgPSBnYW1lLm1vdmVNYXA7XG5cblxuXG4vLyBIYW5kbGVzIG1hcCB3aWR0aCBhbmQgbWFwIGhlaWdodCBkaXNwbGF5IGRpbWVuc2lvbnMgaWYgdGhleSBhcmUgYmFkIGlucHV0cyAtIGVpdGhlciB0b29cbi8vIGxhcmdlIChsYXJnZXIgdGhhbiBtYXApIG9yIHRvbyBzbWFsbCAoPD0gMCkuIEZpeGVzIHRoZSBkaW1lbnNpb25zIG9yIHRocm93cyBhbiBlcnJvci5cbi8vIEZpcnN0IHBhcmFtZXRlciBpcyB0aGUgZGltZW5zaW9uIG9mIHRoZSBtYXAgYmVpbmcgZGlzcGxheWVkLCBzZWNvbmQgcGFyYW1ldGVyIGlzIHRoZSBtYXAnc1xuLy8gdG90YWwgc2l6ZSBpbiB0aGF0IGRpbWVuc2lvbi5cbmdhbWUudmVyaWZ5TWFwRGltZW5zaW9uID0gZnVuY3Rpb24oZGlzcGxheURpbWVuLCB0b3RhbERpbWVuKSB7XG4gIHRyeSB7XG4gICAgLy8gaWYgbWFwSGVpZ2h0IG9yIG1hcFdpZHRoIGlzIGdpdmVuIGFzIDAgb3IgbmVnYXRpdmUsIHRocm93IGFuIGVycm9yLlxuICAgIGlmIChkaXNwbGF5RGltZW4gPD0gMClcbiAgICAgIHRocm93IG5ldyBjdXN0b21FcnJvcihcIlplcm8gb3IgbmVnYXRpdmUgbnVtYmVyIHNlbnQgdG8gZHJhd01hcCgpIGZvciB2aWV3YWJsZSBtYXAgZGltZW5zaW9uIHBhcmFtZXRlclwiKTtcbiAgICAvLyBpZiBkaXNwbGF5IGRpbWVuc2lvbiBpcyBsYXJnZXIgdGhhbiBtYXAgc2V0IGl0IGVxdWFsIHRvIHRoYXQgb2YgZW50aXJlIG1hcFxuICAgIGVsc2UgaWYgKGRpc3BsYXlEaW1lbiA+IHRvdGFsRGltZW4pXG4gICAgICBkaXNwbGF5RGltZW4gPSB0b3RhbERpbWVuO1xuICB9IGNhdGNoKGVycikgeyBjb25zb2xlLmxvZyhlcnIpOyB9ICAgICAgICAgIC8vIHByaW50IHBvc3NpYmxlIGVycm9yIHRvIGNvbnNvbGVcbiAgZmluYWxseSB7IHJldHVybiBkaXNwbGF5RGltZW47IH1cbn07XG5cblxuXG5cbi8vIENyZWF0aW5nIGEgZnVuY3Rpb24gdG8gY2FsbCB0byBkaXNwbGF5IGN1c3RvbSBlcnJvcnMuIEp1c3QgZG86IHRocm93IG5ldyBjdXN0b21FcnJvcigpXG4vLyB3aXRoIHRoZSBlcnJvciBtZXNzYWdlIGFzIHRoZSBhcmd1bWVudC4gVGhlbiBzZW5kIHRoZSBlcnJvciB0byB0aGUgY29uc29sZS5sb2coKSBpbiB0aGVcbi8vIGNhdGNoIGJsb2NrLiBUaGlzIGNhbiBhbHNvIGJlIHBhcnQgb2YgbXkgcm9ndWVsaWtlIGdhbWUgZGV2IGxpYnJhcnkgc2luY2UgSSBnaXZlIHRoZVxuLy8gZXJyb3JzIGEgbmFtZSBhcHByb3ByaWF0ZSB0byB0aGUgbGlicmFyeS5cbmdhbWUuY3VzdG9tRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIHRoaXMuc3RhY2sgPSBuZXcgRXJyb3IoKS5zdGFjaztcbiAgdGhpcy5uYW1lID0gXCJUb2RkIFJvZ3VlbGlrZSBMaWJyYXJ5IEVycm9yXCI7XG4gIHRoaXMubWVzc2FnZSA9IChtZXNzYWdlIHx8IFwiXCIpO1xufTtcbmdhbWUuY3VzdG9tRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7Ly9FcnJvci5wcm90b3R5cGU7XG5cbi8vIEFub3RoZXIgd2F5IG9mIGRvaW5nIGEgY3VzdG9tIGVycm9yOlxuICAgIC8vIGZ1bmN0aW9uIGN1c3RvbUVycm9yKCkge1xuICAgIC8vICAgICB2YXIgZXJyID0gRXJyb3IuYXBwbHkodGhpcyxhcmd1bWVudHMpO1xuICAgIC8vICAgICBlcnIubmFtZSA9IHRoaXMubmFtZSA9IFwiVG9kZCBMaWJyYXJ5IEVycm9yXCI7XG4gICAgLy8gICAgIHRoaXMuc3RhY2sgPSBlcnIuc3RhY2s7XG4gICAgLy8gICAgIC8vIHRoaXMubWVzc2FnZSA9IGVyci5tZXNzYWdlO1xuICAgIC8vICAgICByZXR1cm4gdGhpcztcbiAgICAvLyB9XG5cbiAgICAvLyBmdW5jdGlvbiB1cGRhdGVQbGF5ZXJUb01hcCgpIHtcblxuICAgIC8vIH1cblxuLy8gT25jZSB0aGUgcGxheWVyIGhhcyBtb3ZlZCB0aGlzIGZ1bmN0aW9uIGNsZWFycyBmcm9tIHRoZSBkaXNwbGF5IHdoYXQgaXMgbm9ybWFsbHlcbi8vIG9jY3VweWluZyB0aGF0IHNwYWNlIG9uIHRoZSBtYXAsIGFuZCBvdXRwdXRzIHRoZSBwbGF5ZXIncyBjaGFyYWN0ZXIgaW5zdGVhZC5cbmdhbWUudXBkYXRlUGxheWVyVG9NYXAgPSBmdW5jdGlvbihtYXBYLCBtYXBZKSB7Ly8sIG1hcFdpZHRoLCBtYXBIZWlnaHQpIHtcbiAgY29uc29sZS5sb2coJ2dhbWUnLCBnYW1lKTtcbiAgY29uc29sZS5sb2coZ2FtZS5wbGF5ZXIueCk7XG4gIGlmIChnYW1lLm1hcFtnYW1lLnBsYXllci54XVtnYW1lLnBsYXllci55XSAhPSBcIiNcIikge1xuICAgIC8vIGNsZWFyIGRpc3BsYXkgc3BhY2Ugd2hlcmUgcGxheWVyIGlzIG1vdmluZyB0by5cbiAgICBnYW1lLmN0eC5jbGVhclJlY3QoZ2FtZS5wbGF5ZXIueCpnYW1lLmdyaWRTaXplK21hcFgsIGdhbWUucGxheWVyLnkqZ2FtZS5ncmlkU2l6ZSttYXBZLCBnYW1lLmdyaWRTaXplLCBnYW1lLmdyaWRTaXplKTtcbiAgICAvLyBvdXRwdXQgdGhlIHBsYXllciB0byB0aGUgc2NyZWVuIGluIHRoZSBjb3JyZWN0IHNwb3RcbiAgICBnYW1lLmN0eC5maWxsU3R5bGUgPSBnYW1lLnBsYXllci5jb2xvcjtcbiAgICBnYW1lLmN0eC5maWxsVGV4dChnYW1lLnBsYXllci5hdmF0YXIsIGdhbWUucGxheWVyLngqZ2FtZS5ncmlkU2l6ZSsoZ2FtZS5ncmlkU2l6ZS8yKSttYXBYLCBnYW1lLnBsYXllci55KmdhbWUuZ3JpZFNpemUrbWFwWSk7XG4gIH0gZWxzZSB7XG4gICAgZ2FtZS5wbGF5ZXIueCArPSAtZ2FtZS5wbGF5ZXIubGFzdE1vdmVbMF07XG4gICAgZ2FtZS5wbGF5ZXIueSArPSAtZ2FtZS5wbGF5ZXIubGFzdE1vdmVbMV07XG4gIH1cbn07XG5cbi8vIEdhbWUgdXBkYXRlIGZ1bmN0aW9uICh0aGUgZ2FtZSBsb29wKVxuZ2FtZS51cGRhdGUgPSBmdW5jdGlvbigpIHtcblxuICBnYW1lLm1hcC5kcmF3TWFwKGZhbHNlLCBbXCJncmVlblwiLFwiYmx1ZVwiXSwgMTAsIDMzLCAxMDAsIDUwKTsvLywgXCJyZ2IoMCwyMDAsMClcIik7XG59XG4qL1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi4vZ2FtZUxpYi9pbmRleC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n");

/***/ })
/******/ ]);